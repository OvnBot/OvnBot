<!-- mon-super-bot-stream/public/viewer.html -->

<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Visionneuse de Streams</title>
    <script src="https://cdn.jsdelivr.net/npm/flv.js@1.6.2/dist/flv.min.js"></script>
    <style>
        :root {
            --background: #0d1117;
            --surface: #161b22;
            --primary: #58a6ff;
            --primary-glow: rgba(88, 166, 255, 0.5);
            --text-primary: #c9d1d9;
            --text-secondary: #8b949e;
            --border: #30363d;
        }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background: var(--background); color: var(--text-primary); margin: 0; padding: 20px; }
        header { display: flex; justify-content: space-between; align-items: center; max-width: 1600px; margin: 0 auto 40px auto; }
        header h1 { font-size: 2.5em; color: var(--primary); text-shadow: 0 0 10px var(--primary-glow); margin: 0; }
        .admin-button { background: var(--surface); border: 1px solid var(--border); color: var(--text-primary); padding: 10px 15px; text-decoration: none; border-radius: 5px; transition: all 0.2s; }
        .admin-button:hover { background: var(--border); color: var(--primary); }
        #stream-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(350px, 1fr)); gap: 20px; max-width: 1600px; margin: auto; }
        .stream-player-card { background: var(--surface); border: 1px solid var(--border); border-radius: 8px; overflow: hidden; cursor: pointer; transition: all 0.3s ease; }
        .stream-player-card:hover { transform: scale(1.02); box-shadow: 0 0 15px var(--primary-glow); }
        .player-wrapper { position: relative; background: #000; width: 100%; padding-top: 56.25%; }
        .player-wrapper video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; object-fit: contain; }
        .stream-title { padding: 15px; font-size: 1.2em; font-weight: bold; }
        
        /* Nouvel overlay de statut (pour masqu√© et hors ligne) */
        .status-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 1.8em;
            font-weight: bold;
            z-index: 10;
            text-align: center;
            background: radial-gradient(circle, rgba(22,27,34,0.8) 0%, rgba(13,17,23,0.95) 100%);
        }
        .status-overlay .icon { font-size: 3em; line-height: 1; margin-bottom: 15px; }
        .status-overlay.hidden .icon { animation: pulse 2s infinite; color: #ffc107; }
        .status-overlay.offline .icon { color: var(--text-secondary); }
        @keyframes pulse { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.6; transform: scale(0.95); } }

        /* Bouton Play pour mobile */
        .play-button-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5);
            display: flex; align-items: center; justify-content: center;
            font-size: 4em; color: white;
            cursor: pointer; z-index: 11;
            transition: opacity 0.3s;
        }
        .play-button-overlay:hover { opacity: 0.8; }
        .play-button-overlay.hidden { display: none; }


        .no-streams { text-align: center; font-size: 1.5em; color: var(--text-secondary); }
        /* Styles pour la vue focus */
        .focused-view { display: flex; flex-direction: column; height: 100vh; padding: 0; }
        .focused-view header { padding: 20px; margin-bottom: 0; }
        .focused-view #stream-grid {
            display: flex;
            flex-grow: 1;
            align-items: center;
            justify-content: center;
            padding: 20px;
            min-height: 0; /* Important pour le flexbox dans certains navigateurs */
        }
        .focused-view .stream-player-card {
            width: 100%;
            height: 100%;
        }
        .focused-view .stream-player-card { cursor: default; }
        .focused-view .stream-player-card:hover { transform: none; box-shadow: none; }        

        /* Masquer les contr√¥les vid√©o non d√©sir√©s */
        video::-webkit-media-controls-play-button,
        video::-webkit-media-controls-timeline,
        video::-webkit-media-controls-current-time-display,
        video::-webkit-media-controls-time-remaining-display,
        video::-webkit-media-controls-fullscreen-button {
            display: none !important;
        }

        /* Styles pour la version mobile */
        @media (max-width: 768px) {
            body { padding: 10px; }
            #stream-grid { grid-template-columns: 1fr; gap: 15px; }
            header h1 { font-size: 1.8em; }
        }
    </style>
</head>
<body>

    <header>
        <h1>Streams en Direct</h1>
        <a href="/admin" class="admin-button">Espace Admin</a>
    </header>

    <div id="stream-grid">
        <p class="no-streams">Aucun stream en direct pour le moment...</p>
    </div>

    <script>
        let activePlayers = {};
        let liveStreams = {};

        async function fetchAndDisplayStreams() {
            try {
                const response = await fetch('/api/public/streams'); // Cet endpoint ne retournera d√©sormais que les streams diffus√©s
                liveStreams = await response.json(); // Assigner √† la variable globale liveStreams
                const liveStreamNames = Object.keys(liveStreams);
                const grid = document.getElementById('stream-grid');
                const currentlyDisplayed = new Set(Object.keys(activePlayers));
                const isFocused = document.body.classList.contains('focused-view');

                // Mettre √† jour l'√©tat "masqu√©" des streams d√©j√† affich√©s
                for (const streamName of currentlyDisplayed) {
                    if (liveStreams[streamName]) {
                        const card = document.getElementById(`stream-card-${streamName}`);
                        if (!card) continue; // S√©curit√© si la carte a √©t√© supprim√©e
                        const overlay = card.querySelector('.status-overlay');
                        const playerWrapper = card.querySelector('.player-wrapper');
                        if (liveStreams[streamName].hidden && !overlay) {
                            // Arr√™te le lecteur et affiche l'overlay "masqu√©"
                            activePlayers[streamName]?.destroy();
                            delete activePlayers[streamName];
                            playerWrapper.innerHTML = `<div class="status-overlay hidden"><div class="icon">üëÅÔ∏è</div><div>STREAM MASQU√â</div></div>`;
                            card.onclick = () => focusOnStream(streamName, liveStreams); // Mettre √† jour le clic
                        } else if (!liveStreams[streamName].hidden && overlay && overlay.classList.contains('hidden')) {
                            // L'overlay "masqu√©" existe mais ne devrait plus. On le remplace par le lecteur vid√©o.
                            console.log(`[Viewer] D√©masquage du stream ${streamName}.`);
                            playerWrapper.innerHTML = `<video id="video-${streamName}" autoplay controls muted></video>`;
                            
                            // On relance le lecteur vid√©o pour ce stream
                            const videoElement = document.getElementById(`video-${streamName}`);
                            if (videoElement) {
                                initializePlayer(streamName, videoElement);
                            }
                            card.onclick = () => focusOnStream(streamName, liveStreams);
                        }
                    }
                }

                // G√©rer les streams qui se sont arr√™t√©s
                for (const streamName of currentlyDisplayed) {
                    if (!liveStreamNames.includes(streamName)) {
                        console.log(`Stream ${streamName} est hors ligne. Nettoyage.`);
                        activePlayers[streamName]?.destroy();
                        delete activePlayers[streamName];
                        const card = document.getElementById(`stream-card-${streamName}`);
                        if (card) {
                            const playerWrapper = card.querySelector('.player-wrapper');
                            playerWrapper.innerHTML = `<div class="status-overlay offline"><div class="icon">‚ö´</div><div>HORS LIGNE</div></div>`;
                            card.onclick = null; // D√©sactive le clic sur la carte
                            card.style.cursor = 'default';
                        }
                    }
                }

                // G√©rer les nouveaux streams
                for (const streamName of liveStreamNames) {
                    if (!currentlyDisplayed.has(streamName)) {
                        console.log(`Nouveau stream d√©tect√©: ${streamName}.`);
                        if (grid.querySelector('p')) {
                            grid.innerHTML = '';
                        }
                        createStreamCard(streamName, grid, liveStreams);
                    }
                }

                if (liveStreamNames.length === 0 && grid.children.length === 0) {
                    grid.innerHTML = '<p class="no-streams">Aucun stream en direct pour le moment...</p>';
                }

                // Si un stream est sp√©cifi√© dans l'URL, on le fait d√©filer
                const urlParams = new URLSearchParams(window.location.search);
                const focusedStreamName = urlParams.get('stream');
                if (focusedStreamName && liveStreamNames.includes(focusedStreamName) && !isFocused) {
                    focusOnStream(focusedStreamName, liveStreams);
                }

            } catch (error) {
                console.error("Erreur lors de la r√©cup√©ration des streams:", error);
            }
        }

        function createStreamCard(streamName, container, allStreams) {
            const isHidden = allStreams[streamName].hidden;
            const card = document.createElement('div');
            card.className = 'stream-player-card';
            card.id = `stream-card-${streamName}`;
            card.onclick = () => focusOnStream(streamName, allStreams);
            card.innerHTML = `
                <div class="player-wrapper">
                    ${isHidden ? '<div class="status-overlay hidden"><div class="icon">üëÅÔ∏è</div><div>STREAM MASQU√â</div></div>' : ''}
                    <div class="play-button-overlay" id="play-btn-${streamName}">‚ñ∂</div>
                    <video id="video-${streamName}" autoplay controls muted></video>
                </div>
                <div class="stream-title">${streamName}</div>
            `;
            container.appendChild(card);

            if (flvjs.isSupported() && !isHidden) {
                const videoElement = document.getElementById(`video-${streamName}`);
                const playButton = document.getElementById(`play-btn-${streamName}`);
                
                // On associe le clic sur le bouton Play √† l'initialisation du lecteur
                playButton.onclick = (e) => {
                    e.stopPropagation(); // Emp√™che le clic de d√©clencher le mode focus
                    initializePlayer(streamName, videoElement, playButton);
                };
            }
        }

        function initializePlayer(streamName, videoElement, playButton) {
            if (!videoElement) {
                console.warn(`√âl√©ment vid√©o pour ${streamName} non trouv√©.`);
                return;
            }
            // Masquer le bouton play une fois cliqu√©
            if (playButton) playButton.classList.add('hidden');

            videoElement.onplay = () => {
                document.querySelectorAll('video').forEach(v => {
                    if (v !== videoElement) v.muted = true;
                });
            };

            const flvPlayer = flvjs.createPlayer({
                type: 'flv', isLive: true,
                url: `http://${window.location.hostname}:8000/live/${streamName}.flv`
            });
            flvPlayer.attachMediaElement(videoElement);
            flvPlayer.load();
            videoElement.play().catch(e => console.error("La lecture a √©chou√©:", e)); // Essaye de jouer, en ignorant les erreurs d'autoplay
            activePlayers[streamName] = flvPlayer;
        }

        function focusOnStream(streamName, allStreams) {
            document.body.classList.add('focused-view');
            // Si le stream sur lequel on clique est masqu√©, on ne fait rien de plus que d'afficher la carte masqu√©e.
            if (allStreams[streamName] && allStreams[streamName].hidden) {
                const grid = document.getElementById('stream-grid');
                grid.innerHTML = ''; // Vide la grille
                createStreamCard(streamName, grid, allStreams);
            } else {
                const grid = document.getElementById('stream-grid');
                grid.innerHTML = ''; // Vide la grille
                createStreamCard(streamName, grid, allStreams);
            }

            // Change le titre et ajoute un bouton de retour
            const header = document.querySelector('header');
            header.innerHTML = `
                <h1>${streamName}</h1>
                <a href="javascript:showGridView()" class="admin-button">Retour √† la grille</a>
            `;
        }

        function showGridView() {
            document.body.classList.remove('focused-view');
            const header = document.querySelector('header');
            header.innerHTML = `
                <h1>Streams en Direct</h1>
                <a href="/admin" class="admin-button">Espace Admin</a>
            `;
            // Vide la grille et relance un rafra√Æchissement pour reconstruire
            const grid = document.getElementById('stream-grid');
            grid.innerHTML = '';
            Object.keys(activePlayers).forEach(k => activePlayers[k].destroy());
            activePlayers = {};
            fetchAndDisplayStreams();
        }

        // Lancement
        setInterval(fetchAndDisplayStreams, 2000); // Intervalle r√©duit √† 2 secondes
        fetchAndDisplayStreams();
    </script>

</body>
</html>